// Copyright 2022 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.15 or later.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"reflect"
	"strconv"
	"syscall/js"

	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"

	_ "golang.org/x/image/tiff"

	"github.com/xuri/excelize"
)

type argsRule struct {
	opts  bool
	types []js.Type
}

var (
	f          *excelize.File
	fn         = make(map[string]interface{})
	errArgNum  = errors.New("not enough arguments in call")
	errArgType = errors.New("invalid argument data type")
)

func main() {
	c := make(chan struct{})
	regInteropFunc()
	<-c
}

func regInteropFunc() {
	for name, impl := range map[string]func(this js.Value, args []js.Value) interface{}{
		"AddChart":               AddChart,
		"AddChartSheet":          AddChartSheet,
		"AddComment":             AddComment,
		"AddPictureFromBytes":    AddPictureFromBytes,
		"AddPivotTable":          AddPivotTable,
		"AddShape":               AddShape,
		"AddTable":               AddTable,
		"AutoFilter":             AutoFilter,
		"CalcCellValue":          CalcCellValue,
		"CopySheet":              CopySheet,
		"DeleteChart":            DeleteChart,
		"DeleteComment":          DeleteComment,
		"DeleteDataValidation":   DeleteDataValidation,
		"DeletePicture":          DeletePicture,
		"DeleteSheet":            DeleteSheet,
		"DuplicateRow":           DuplicateRow,
		"DuplicateRowTo":         DuplicateRowTo,
		"GetActiveSheetIndex":    GetActiveSheetIndex,
		"GetAppProps":            GetAppProps,
		"GetCellFormula":         GetCellFormula,
		"GetCellHyperLink":       GetCellHyperLink,
		"GetCellStyle":           GetCellStyle,
		"GetCellValue":           GetCellValue,
		"GetColOutlineLevel":     GetColOutlineLevel,
		"GetColStyle":            GetColStyle,
		"GetColVisible":          GetColVisible,
		"GetColWidth":            GetColWidth,
		"GetCols":                GetCols,
		"GetRowHeight":           GetRowHeight,
		"GetRowOutlineLevel":     GetRowOutlineLevel,
		"GetRowVisible":          GetRowVisible,
		"GetRows":                GetRows,
		"GetSheetIndex":          GetSheetIndex,
		"GetSheetList":           GetSheetList,
		"GetSheetMap":            GetSheetMap,
		"GetSheetName":           GetSheetName,
		"GetSheetVisible":        GetSheetVisible,
		"GroupSheets":            GroupSheets,
		"InsertCols":             InsertCols,
		"InsertPageBreak":        InsertPageBreak,
		"InsertRows":             InsertRows,
		"MergeCell":              MergeCell,
		"NewConditionalStyle":    NewConditionalStyle,
		"NewSheet":               NewSheet,
		"NewStyle":               NewStyle,
		"RemoveCol":              RemoveCol,
		"RemovePageBreak":        RemovePageBreak,
		"RemoveRow":              RemoveRow,
		"SearchSheet":            SearchSheet,
		"SetActiveSheet":         SetActiveSheet,
		"SetCellBool":            SetCellBool,
		"SetCellDefault":         SetCellDefault,
		"SetCellFloat":           SetCellFloat,
		"SetCellInt":             SetCellInt,
		"SetCellStr":             SetCellStr,
		"SetCellStyle":           SetCellStyle,
		"SetCellValue":           SetCellValue,
		"SetColOutlineLevel":     SetColOutlineLevel,
		"SetColStyle":            SetColStyle,
		"SetColVisible":          SetColVisible,
		"SetColWidth":            SetColWidth,
		"SetConditionalFormat":   SetConditionalFormat,
		"SetDefaultFont":         SetDefaultFont,
		"SetPanes":               SetPanes,
		"SetRowHeight":           SetRowHeight,
		"SetRowOutlineLevel":     SetRowOutlineLevel,
		"SetRowStyle":            SetRowStyle,
		"SetRowVisible":          SetRowVisible,
		"SetSheetCol":            SetSheetCol,
		"SetSheetName":           SetSheetName,
		"SetSheetRow":            SetSheetRow,
		"SetSheetVisible":        SetSheetVisible,
		"UngroupSheets":          UngroupSheets,
		"UnmergeCell":            UnmergeCell,
		"UnprotectSheet":         UnprotectSheet,
		"UnsetConditionalFormat": UnsetConditionalFormat,
		"UpdateLinkedValue":      UpdateLinkedValue,
		"WriteToBuffer":          WriteToBuffer,
	} {
		fn[name] = js.FuncOf(impl)
	}
	for name, impl := range map[string]func(this js.Value, args []js.Value) interface{}{
		"CellNameToCoordinates": CellNameToCoordinates,
		"ColumnNameToNumber":    ColumnNameToNumber,
		"ColumnNumberToName":    ColumnNumberToName,
		"CoordinatesToCellName": CoordinatesToCellName,
		"HSLToRGB":              HSLToRGB,
		"JoinCellName":          JoinCellName,
		"RGBToHSL":              RGBToHSL,
		"SplitCellName":         SplitCellName,
		"ThemeColor":            ThemeColor,
		"NewFile":               NewFile,
		"OpenReader":            OpenReader,
	} {
		js.Global().Set(name, js.FuncOf(impl))
	}
}

func inTypeSlice(a []js.Type, x js.Type) int {
	for idx, n := range a {
		if x == n {
			return idx
		}
	}
	return -1
}

func prepareOptions(arg js.Value) (excelize.Options, error) {
	var opts excelize.Options
	passwd := arg.Get("password")
	if passwd.Type() != js.TypeUndefined {
		if passwd.Type() != js.TypeString {
			return opts, errArgType
		}
		opts.Password = passwd.String()
	}
	rawCellValue := arg.Get("raw_cell_value")
	if rawCellValue.Type() != js.TypeUndefined {
		if rawCellValue.Type() != js.TypeBoolean {
			return opts, errArgType
		}
		opts.RawCellValue = rawCellValue.Bool()
	}
	return opts, nil
}

func prepareArgs(args []js.Value, types []argsRule) error {
	rules, arguments, opts := len(types), len(args), false
	if rules > 0 && types[rules-1].opts {
		opts = true
	}
	if (!opts && arguments != rules) || (opts && (arguments != rules && arguments+1 != rules)) {
		return errArgNum
	}
	for i := 0; i < len(types); i++ {
		if opts && i == arguments {
			return nil
		}
		excepted, received := types[i], args[i]
		if inTypeSlice(excepted.types, received.Type()) == -1 {
			return errArgType
		}
	}
	return nil
}

func CellNameToCoordinates(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	col, row, err := excelize.CellNameToCoordinates(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], ret["row"] = col, row
	return js.ValueOf(ret)
}

func ColumnNameToNumber(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], err = excelize.ColumnNameToNumber(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func ColumnNumberToName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeNumber}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], err = excelize.ColumnNumberToName(args[0].Int())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func CoordinatesToCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeBoolean}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var abs bool
	if len(args) == 3 {
		abs = args[2].Bool()
	}
	ret["cell"], err = excelize.CoordinatesToCellName(args[0].Int(), args[1].Int(), abs)
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func HSLToRGB(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["r"], ret["g"], ret["b"] = excelize.HSLToRGB(args[0].Float(), args[1].Float(), args[2].Float())
	return js.ValueOf(ret)
}

func JoinCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["cell"], err = excelize.JoinCellName(args[0].String(), args[1].Int())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func RGBToHSL(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["h"], ret["s"], ret["l"] = excelize.RGBToHSL(uint8(args[0].Int()), uint8(args[1].Int()), uint8(args[2].Int()))
	return js.ValueOf(ret)
}

func SplitCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], ret["row"], err = excelize.SplitCellName(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func ThemeColor(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["color"] = excelize.ThemeColor(args[0].String(), args[1].Float())
	return js.ValueOf(ret)
}

func NewFile(this js.Value, args []js.Value) interface{} {
	fn["error"] = nil
	if err := prepareArgs(args, []argsRule{}); err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	f = excelize.NewFile()
	return js.ValueOf(fn)
}

func OpenReader(this js.Value, args []js.Value) interface{} {
	fn["error"] = nil
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeObject}},
		{types: []js.Type{js.TypeObject}, opts: true},
	})
	if err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	if args[0].Length() == 0 {
		fn["error"] = excelize.ErrParameterInvalid.Error()
		return js.ValueOf(fn)
	}
	buf := make([]byte, args[0].Get("length").Int())
	js.CopyBytesToGo(buf, args[0])
	var opts excelize.Options
	if len(args) == 2 {
		if opts, err = prepareOptions(args[1]); err != nil {
			fn["error"] = err.Error()
			return js.ValueOf(fn)
		}
	}
	if f, err = excelize.OpenReader(bytes.NewReader(buf), opts); err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	return js.ValueOf(fn)
}

func AddChart(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if len(args) == 4 {
		err = f.AddChart(args[0].String(), args[1].String(), args[2].String(), args[3].String())
	} else {
		err = f.AddChart(args[0].String(), args[1].String(), args[2].String())
	}
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AddChartSheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if len(args) == 3 {
		err = f.AddChartSheet(args[0].String(), args[1].String(), args[2].String())
	} else {
		err = f.AddChartSheet(args[0].String(), args[1].String())
	}
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AddComment(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.AddComment(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AddPictureFromBytes(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeObject}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	buf := make([]byte, args[5].Get("length").Int())
	js.CopyBytesToGo(buf, args[5])
	if err := f.AddPictureFromBytes(args[0].String(), args[1].String(), args[2].String(), args[3].String(), args[4].String(), buf); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AddPivotTable(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var opt excelize.PivotTableOption
	if err := json.Unmarshal([]byte(args[0].String()), &opt); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.AddPivotTable(&opt); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AddShape(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.AddShape(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AddTable(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.AddTable(args[0].String(), args[1].String(), args[2].String(), args[3].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func AutoFilter(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.AutoFilter(args[0].String(), args[1].String(), args[2].String(), args[3].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func CalcCellValue(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["value"], err = f.CalcCellValue(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func CopySheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.CopySheet(args[0].Int(), args[1].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func DeleteChart(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.DeleteChart(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func DeleteComment(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.DeleteComment(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func DeleteDataValidation(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if len(args) == 2 {
		err = f.DeleteDataValidation(args[0].String(), args[1].String())
	} else {
		err = f.DeleteDataValidation(args[0].String())
	}
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func DeletePicture(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.DeletePicture(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func DeleteSheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	f.DeleteSheet(args[0].String())
	return js.ValueOf(ret)
}

func DuplicateRow(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.DuplicateRow(args[0].String(), args[1].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func DuplicateRowTo(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.DuplicateRowTo(args[0].String(), args[1].Int(), args[2].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetActiveSheetIndex(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["index"] = f.GetActiveSheetIndex()
	return js.ValueOf(ret)
}

func GetAppProps(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	props, err := f.GetAppProps()
	if err != nil {
		ret["error"] = err.Error()
	}
	s := reflect.ValueOf(props).Elem()
	for i := 0; i < s.NumField(); i++ {
		ret[s.Type().Field(i).Tag.Get("json")] = s.Field(i).Interface()
	}
	return js.ValueOf(ret)
}

func GetCellFormula(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["formula"], err = f.GetCellFormula(args[0].String(), args[1].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetCellHyperLink(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["ok"], ret["location"], err = f.GetCellHyperLink(args[0].String(), args[1].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetCellStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["style"], err = f.GetCellStyle(args[0].String(), args[1].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetCellValue(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["value"], err = f.GetCellValue(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	return js.ValueOf(ret)
}

func GetColOutlineLevel(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["level"], err = f.GetColOutlineLevel(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetColStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["style"], err = f.GetColStyle(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetColVisible(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["visible"], err = f.GetColVisible(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetColWidth(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["width"], err = f.GetColWidth(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetCols(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeObject}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var opts excelize.Options
	if len(args) == 2 {
		if opts, err = prepareOptions(args[1]); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
	}
	matrix, err := f.GetCols(args[0].String(), opts)
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	result := make([]interface{}, len(matrix))
	for c, col := range matrix {
		line := make([]interface{}, len(col))
		for r, cell := range col {
			line[r] = cell
		}
		result[c] = js.ValueOf(line)
	}
	ret["result"] = result
	return js.ValueOf(ret)
}

func GetRowHeight(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["height"], err = f.GetRowHeight(args[0].String(), args[1].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetRowOutlineLevel(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["level"], err = f.GetRowOutlineLevel(args[0].String(), args[1].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetRowVisible(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["visible"], err = f.GetRowVisible(args[0].String(), args[1].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func GetRows(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeObject}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var opts excelize.Options
	if len(args) == 2 {
		if opts, err = prepareOptions(args[1]); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
	}
	matrix, err := f.GetRows(args[0].String(), opts)
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	result := make([]interface{}, len(matrix))
	for r, row := range matrix {
		line := make([]interface{}, len(row))
		for c, cell := range row {
			line[c] = cell
		}
		result[r] = js.ValueOf(line)
	}
	ret["result"] = result
	return js.ValueOf(ret)
}

func GetSheetIndex(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["index"] = f.GetSheetIndex(args[0].String())
	return js.ValueOf(ret)
}

func GetSheetList(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	sheetList := f.GetSheetList()
	expected := make([]interface{}, len(sheetList))
	for i, name := range sheetList {
		expected[i] = name
	}
	ret["list"] = expected
	return js.ValueOf(ret)
}

func GetSheetMap(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	sheetMap := f.GetSheetMap()
	result := make(map[string]interface{}, len(sheetMap))
	for i, name := range sheetMap {
		result[strconv.Itoa(i)] = name
	}
	ret["sheets"] = result
	return js.ValueOf(ret)
}

func GetSheetName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["name"] = f.GetSheetName(args[0].Int())
	return js.ValueOf(ret)
}

func GetSheetVisible(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["visible"] = f.GetSheetVisible(args[0].String())
	return js.ValueOf(ret)
}

func GroupSheets(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeObject}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	length := args[0].Length()
	var slice []string
	for i := 0; i < length; i++ {
		arg := args[0].Index(i)
		switch arg.Type() {
		case js.TypeString:
			slice = append(slice, arg.String())
		default:
		}
	}
	if err := f.GroupSheets(slice); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func InsertCols(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.InsertCols(args[0].String(), args[1].String(), args[2].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func InsertPageBreak(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.InsertPageBreak(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func InsertRows(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.InsertRows(args[0].String(), args[1].Int(), args[2].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func MergeCell(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.MergeCell(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func NewConditionalStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["style"], err = f.NewConditionalStyle(args[0].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func NewSheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["index"] = f.NewSheet(args[0].String())
	return js.ValueOf(ret)
}

func NewStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if ret["style"], err = f.NewStyle(args[0].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func RemoveCol(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.RemoveCol(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func RemovePageBreak(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.RemovePageBreak(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func RemoveRow(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.RemoveRow(args[0].String(), args[1].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SearchSheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeBoolean}, opts: true},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var reg bool
	if len(args) == 3 {
		reg = args[2].Bool()
	}
	result, err := f.SearchSheet(args[0].String(), args[1].String(), reg)
	if err != nil {
		ret["error"] = err.Error()
	}
	excepted := make([]interface{}, len(result))
	for i, cell := range result {
		excepted[i] = cell
	}
	ret["result"] = excepted
	return js.ValueOf(ret)
}

func SetActiveSheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	f.SetActiveSheet(args[0].Int())
	return js.ValueOf(ret)
}

func SetCellBool(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeBoolean}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetCellBool(args[0].String(), args[1].String(), args[2].Bool()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetCellDefault(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetCellDefault(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetCellFloat(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetCellFloat(args[0].String(), args[1].String(), args[2].Float(), args[3].Int(), args[4].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetCellInt(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetCellInt(args[0].String(), args[1].String(), args[2].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetCellStr(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetCellStr(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetCellStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetCellStyle(args[0].String(), args[1].String(), args[2].String(), args[3].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetCellValue(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeBoolean, js.TypeNumber, js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var value interface{}
	switch args[2].Type() {
	case js.TypeBoolean:
		value = args[2].Bool()
	case js.TypeNumber:
		value = args[2].Float()
	case js.TypeString:
		value = args[2].String()
	default:
	}
	if err := f.SetCellValue(args[0].String(), args[1].String(), value); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetColOutlineLevel(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetColOutlineLevel(args[0].String(), args[1].String(), uint8(args[2].Int())); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetColStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetColStyle(args[0].String(), args[1].String(), args[2].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetColVisible(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeBoolean}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetColVisible(args[0].String(), args[1].String(), args[2].Bool()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetColWidth(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetColWidth(args[0].String(), args[1].String(), args[2].String(), args[3].Float()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetConditionalFormat(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetConditionalFormat(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetDefaultFont(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	f.SetDefaultFont(args[0].String())
	return js.ValueOf(ret)
}

func SetPanes(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetPanes(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetRowHeight(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetRowHeight(args[0].String(), args[1].Int(), args[2].Float()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetRowOutlineLevel(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetRowOutlineLevel(args[0].String(), args[1].Int(), uint8(args[2].Int())); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetRowStyle(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetRowStyle(args[0].String(), args[1].Int(), args[2].Int(), args[3].Int()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetRowVisible(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeBoolean}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetRowVisible(args[0].String(), args[1].Int(), args[2].Bool()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetSheetCol(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeObject}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	length := args[2].Length()
	slice := make([]interface{}, length)
	for i := 0; i < length; i++ {
		arg := args[2].Index(i)
		switch arg.Type() {
		case js.TypeBoolean:
			slice[i] = arg.Bool()
		case js.TypeNumber:
			slice[i] = arg.Float()
		case js.TypeString:
			slice[i] = arg.String()
		default:
		}
	}
	if err := f.SetSheetCol(args[0].String(), args[1].String(), &slice); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetSheetName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	f.SetSheetName(args[0].String(), args[1].String())
	return js.ValueOf(ret)
}

func SetSheetRow(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeObject}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	length := args[2].Length()
	var slice []interface{}
	for i := 0; i < length; i++ {
		arg := args[2].Index(i)
		switch arg.Type() {
		case js.TypeBoolean:
			slice = append(slice, arg.Bool())
		case js.TypeNumber:
			slice = append(slice, arg.Float())
		case js.TypeString:
			slice = append(slice, arg.String())
		default:
			slice = append(slice, nil)
		}
	}
	if err := f.SetSheetRow(args[0].String(), args[1].String(), &slice); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func SetSheetVisible(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeBoolean}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.SetSheetVisible(args[0].String(), args[1].Bool()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func UngroupSheets(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.UngroupSheets(); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func UnmergeCell(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.UnmergeCell(args[0].String(), args[1].String(), args[2].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func UnprotectSheet(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if len(args) == 2 {
		err = f.UnprotectSheet(args[0].String(), args[1].String())
	} else {
		err = f.UnprotectSheet(args[0].String())
	}
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func UnsetConditionalFormat(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeString}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	if err := f.UnsetConditionalFormat(args[0].String(), args[1].String()); err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

func UpdateLinkedValue(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	if err := prepareArgs(args, []argsRule{}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	f.UpdateLinkedValue()
	return js.ValueOf(ret)
}

func WriteToBuffer(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeObject}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var opts excelize.Options
	if len(args) == 1 {
		if opts, err = prepareOptions(args[0]); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
	}
	buf := new(bytes.Buffer)
	if err := f.Write(buf, opts); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	src := buf.Bytes()
	dst := js.Global().Get("Uint8Array").New(len(src))
	js.CopyBytesToJS(dst, src)
	return dst
}
